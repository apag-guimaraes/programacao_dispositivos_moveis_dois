= Handler

Permite a troca de mensagens entre a pilha de execução principal e uma pilha de execução secundária. Lembre-se a função da thread principal é redenrizar 
a interface gráfica. Se há a necessidade de fazer uma conexão remota, isto deve ficar a cargo da thread secundária, se um determinado valor presente na 
thread secundária é necessário para atualizar uma view da interface gráfica, o handler pode ser essa ponte entre as duas threads.

Para mais detalhes sobre handler: GOOGLE DEVELOPERS. Handler. Disponível em: https://developer.android.com/reference/android/os/Handler. Acesso em:
29 ago. 2025.

Exemplo 01 (POST):

- activity_main.xml
[source,xml]
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:gravity="center"
    android:padding="16dp"
    tools:context=".MainActivity">
    <TextView
        android:id="@+id/textViewNumber"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Number"
        android:textSize="24sp"
        android:padding="16dp" />
    <Button
        android:id="@+id/buttonClicar"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="CLICK"
        android:onClick="clicar" />
</LinearLayout>

- MainActivity.java
[source,java]
import androidx.appcompat.app.AppCompatActivity;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import java.util.Random;
public class MainActivity extends AppCompatActivity {
    private TextView textViewNumber;
    private Button buttonClicar;
    private Handler handler;
    private Integer numberG;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        textViewNumber = findViewById(R.id.textViewNumber);
        buttonClicar = findViewById(R.id.buttonClicar);
        handler = new Handler(getMainLooper());
    }
    public void clicar(View view) {
        if (view.getId() == R.id.buttonClicar) {
            buttonClicar.setEnabled(false);
            Log.i("Main", "Thread atual: " + Thread.currentThread());
            Random random = new Random();
            new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 10; i++) {
                        Log.i("Thread", "Thread em execução: " + Thread.currentThread());
                        numberG = random.nextInt(21); 
                        try {
                            Thread.sleep(2000); 
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        handler.post(new Runnable() {
                            @Override
                            public void run() {
                                Log.i("Post", "Thread que atualiza UI: " + Thread.currentThread());
                                textViewNumber.setText(String.valueOf(numberG));
                            }
                        });
                    }
                }
            }).start();
        }
    }
}

Exemplo 02 (MSG):

- activity_main.xml
[source,xml]
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:gravity="center"
    android:padding="16dp"
    tools:context=".MainActivity">
    <TextView
        android:id="@+id/textViewNumber"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!"
        android:textSize="24sp"
        android:padding="16dp" />
    <Button
        android:id="@+id/buttonClicar"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="CLICAR"
        android:onClick="clicar" />
</LinearLayout>

- MainActivity.java
[source,java]
import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import java.util.Random;
public class MainActivity extends AppCompatActivity {
    private TextView textViewNumber;
    private Button buttonClicar;
    private Handler handler;
    private static final String TAG = "Thread-MAIN";
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        textViewNumber = findViewById(R.id.textViewNumber);
        buttonClicar = findViewById(R.id.buttonClicar);
        handler = new Handler(Looper.getMainLooper()) {
            @Override
            public void handleMessage(@NonNull Message msg) {
                textViewNumber.setText(String.valueOf(msg.arg1));
                Log.i(TAG, "UI atualizada na thread: " + Thread.currentThread());
            }
        };
    }
    public void clicar(View view) {
        buttonClicar.setEnabled(false);
        new Thread(() -> {
            Random random = new Random();
            for (int i = 0; i < 10; i++) {
                int num = random.nextInt(21); 
                Message msg = handler.obtainMessage();
                msg.arg1 = num;
                handler.sendMessage(msg);
                try {
                    Thread.sleep(2000); 
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }).start();
    }
    @Override
    protected void onDestroy() {
        super.onDestroy();
        handler.removeCallbacksAndMessages(null);
    }
}


